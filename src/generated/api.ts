/* tslint:disable */
/* eslint-disable */
/**
 * fastapi-react-crm-backend
 * OpenAPI schema
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface BodyUpdateUserMeApiV1UsersMePut
 */
export interface BodyUpdateUserMeApiV1UsersMePut {
    /**
     * 
     * @type {string}
     * @memberof BodyUpdateUserMeApiV1UsersMePut
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof BodyUpdateUserMeApiV1UsersMePut
     */
    'email'?: string;
}
/**
 * 
 * @export
 * @interface Campus
 */
export interface Campus {
    /**
     * 
     * @type {string}
     * @memberof Campus
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof Campus
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface CampusCreate
 */
export interface CampusCreate {
    /**
     * 
     * @type {string}
     * @memberof CampusCreate
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof CampusCreate
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface CampusUpdate
 */
export interface CampusUpdate {
    /**
     * 
     * @type {string}
     * @memberof CampusUpdate
     */
    'address': string;
}
/**
 * 
 * @export
 * @interface Discipline
 */
export interface Discipline {
    /**
     * 
     * @type {string}
     * @memberof Discipline
     */
    'title': string;
    /**
     * 
     * @type {number}
     * @memberof Discipline
     */
    'id'?: number;
}
/**
 * 
 * @export
 * @interface DisciplineCreate
 */
export interface DisciplineCreate {
    /**
     * 
     * @type {string}
     * @memberof DisciplineCreate
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface DisciplineUpdate
 */
export interface DisciplineUpdate {
    /**
     * 
     * @type {string}
     * @memberof DisciplineUpdate
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @interface ReportUserCreate
 */
export interface ReportUserCreate {
    /**
     * 
     * @type {string}
     * @memberof ReportUserCreate
     */
    'start_timestamp': string;
    /**
     * 
     * @type {string}
     * @memberof ReportUserCreate
     */
    'end_timestamp': string;
    /**
     * 
     * @type {string}
     * @memberof ReportUserCreate
     */
    'ext'?: ReportUserCreateExtEnum;
    /**
     * 
     * @type {number}
     * @memberof ReportUserCreate
     */
    'id': number;
}

/**
    * @export
    * @enum {string}
    */
export enum ReportUserCreateExtEnum {
    Csv = 'csv',
    Json = 'json'
}

/**
 * 
 * @export
 * @interface Student
 */
export interface Student {
    /**
     * 
     * @type {string}
     * @memberof Student
     */
    'study_group_cipher_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Student
     */
    'role'?: string;
    /**
     * 
     * @type {number}
     * @memberof Student
     */
    'id'?: number;
}
/**
 * 
 * @export
 * @interface StudentTask
 */
export interface StudentTask {
    /**
     * 
     * @type {number}
     * @memberof StudentTask
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof StudentTask
     */
    'student_id': number;
    /**
     * 
     * @type {string}
     * @memberof StudentTask
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof StudentTask
     */
    'priority': string;
    /**
     * 
     * @type {number}
     * @memberof StudentTask
     */
    'points'?: number;
    /**
     * 
     * @type {string}
     * @memberof StudentTask
     */
    'comment'?: string;
    /**
     * 
     * @type {string}
     * @memberof StudentTask
     */
    'feedback'?: string;
    /**
     * 
     * @type {string}
     * @memberof StudentTask
     */
    'grade'?: string;
    /**
     * 
     * @type {string}
     * @memberof StudentTask
     */
    'deadline_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof StudentTask
     */
    'completion_date'?: string;
}
/**
 * 
 * @export
 * @interface StudentTaskCreate
 */
export interface StudentTaskCreate {
    /**
     * 
     * @type {number}
     * @memberof StudentTaskCreate
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof StudentTaskCreate
     */
    'student_id': number;
    /**
     * 
     * @type {string}
     * @memberof StudentTaskCreate
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof StudentTaskCreate
     */
    'priority': string;
    /**
     * 
     * @type {number}
     * @memberof StudentTaskCreate
     */
    'points'?: number;
    /**
     * 
     * @type {string}
     * @memberof StudentTaskCreate
     */
    'comment'?: string;
    /**
     * 
     * @type {string}
     * @memberof StudentTaskCreate
     */
    'feedback'?: string;
    /**
     * 
     * @type {string}
     * @memberof StudentTaskCreate
     */
    'grade'?: string;
    /**
     * 
     * @type {string}
     * @memberof StudentTaskCreate
     */
    'deadline_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof StudentTaskCreate
     */
    'completion_date'?: string;
}
/**
 * 
 * @export
 * @interface StudentTaskStore
 */
export interface StudentTaskStore {
    /**
     * 
     * @type {number}
     * @memberof StudentTaskStore
     */
    'task_id': number;
    /**
     * 
     * @type {number}
     * @memberof StudentTaskStore
     */
    'student_id': number;
    /**
     * 
     * @type {string}
     * @memberof StudentTaskStore
     */
    'url': string;
    /**
     * 
     * @type {number}
     * @memberof StudentTaskStore
     */
    'size'?: number;
    /**
     * 
     * @type {string}
     * @memberof StudentTaskStore
     */
    'filename'?: string;
    /**
     * 
     * @type {number}
     * @memberof StudentTaskStore
     */
    'id'?: number;
}
/**
 * 
 * @export
 * @interface StudentTaskStoreCreate
 */
export interface StudentTaskStoreCreate {
    /**
     * 
     * @type {number}
     * @memberof StudentTaskStoreCreate
     */
    'task_id': number;
    /**
     * 
     * @type {number}
     * @memberof StudentTaskStoreCreate
     */
    'student_id': number;
    /**
     * 
     * @type {string}
     * @memberof StudentTaskStoreCreate
     */
    'url': string;
    /**
     * 
     * @type {number}
     * @memberof StudentTaskStoreCreate
     */
    'size'?: number;
    /**
     * 
     * @type {string}
     * @memberof StudentTaskStoreCreate
     */
    'filename'?: string;
}
/**
 * 
 * @export
 * @interface StudentTaskStoreUpdate
 */
export interface StudentTaskStoreUpdate {
    /**
     * 
     * @type {number}
     * @memberof StudentTaskStoreUpdate
     */
    'task_id': number;
    /**
     * 
     * @type {number}
     * @memberof StudentTaskStoreUpdate
     */
    'student_id': number;
    /**
     * 
     * @type {string}
     * @memberof StudentTaskStoreUpdate
     */
    'url': string;
    /**
     * 
     * @type {number}
     * @memberof StudentTaskStoreUpdate
     */
    'size'?: number;
    /**
     * 
     * @type {string}
     * @memberof StudentTaskStoreUpdate
     */
    'filename'?: string;
}
/**
 * 
 * @export
 * @interface StudentTaskUpdate
 */
export interface StudentTaskUpdate {
    /**
     * 
     * @type {number}
     * @memberof StudentTaskUpdate
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof StudentTaskUpdate
     */
    'student_id': number;
    /**
     * 
     * @type {string}
     * @memberof StudentTaskUpdate
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof StudentTaskUpdate
     */
    'priority': string;
    /**
     * 
     * @type {number}
     * @memberof StudentTaskUpdate
     */
    'points'?: number;
    /**
     * 
     * @type {string}
     * @memberof StudentTaskUpdate
     */
    'comment'?: string;
    /**
     * 
     * @type {string}
     * @memberof StudentTaskUpdate
     */
    'feedback'?: string;
    /**
     * 
     * @type {string}
     * @memberof StudentTaskUpdate
     */
    'grade'?: string;
    /**
     * 
     * @type {string}
     * @memberof StudentTaskUpdate
     */
    'deadline_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof StudentTaskUpdate
     */
    'completion_date'?: string;
}
/**
 * 
 * @export
 * @interface StudentUpdate
 */
export interface StudentUpdate {
    /**
     * 
     * @type {string}
     * @memberof StudentUpdate
     */
    'study_group_cipher_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof StudentUpdate
     */
    'role'?: string;
}
/**
 * 
 * @export
 * @interface StudyGroup
 */
export interface StudyGroup {
    /**
     * 
     * @type {string}
     * @memberof StudyGroup
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof StudyGroup
     */
    'discipline_id': number;
}
/**
 * 
 * @export
 * @interface StudyGroupCipher
 */
export interface StudyGroupCipher {
    /**
     * 
     * @type {string}
     * @memberof StudyGroupCipher
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface StudyGroupCipherCreate
 */
export interface StudyGroupCipherCreate {
    /**
     * 
     * @type {string}
     * @memberof StudyGroupCipherCreate
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface StudyGroupCipherUpdate
 */
export interface StudyGroupCipherUpdate {
    /**
     * 
     * @type {string}
     * @memberof StudyGroupCipherUpdate
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface StudyGroupCreate
 */
export interface StudyGroupCreate {
    /**
     * 
     * @type {string}
     * @memberof StudyGroupCreate
     */
    'id': string;
    /**
     * 
     * @type {number | Array<number>}
     * @memberof StudyGroupCreate
     */
    'discipline_id': number | Array<number>;
}
/**
 * 
 * @export
 * @interface StudyGroupTask
 */
export interface StudyGroupTask {
    /**
     * 
     * @type {number}
     * @memberof StudyGroupTask
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof StudyGroupTask
     */
    'study_group_cipher_id': string;
    /**
     * 
     * @type {string}
     * @memberof StudyGroupTask
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof StudyGroupTask
     */
    'deadline_date'?: string;
}
/**
 * 
 * @export
 * @interface StudyGroupTaskUpdate
 */
export interface StudyGroupTaskUpdate {
    /**
     * 
     * @type {number}
     * @memberof StudyGroupTaskUpdate
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof StudyGroupTaskUpdate
     */
    'study_group_cipher_id': string;
    /**
     * 
     * @type {string}
     * @memberof StudyGroupTaskUpdate
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof StudyGroupTaskUpdate
     */
    'deadline_date'?: string;
}
/**
 * 
 * @export
 * @interface StudyGroupUpdate
 */
export interface StudyGroupUpdate {
    /**
     * 
     * @type {string}
     * @memberof StudyGroupUpdate
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof StudyGroupUpdate
     */
    'discipline_id': number;
}
/**
 * 
 * @export
 * @interface Task
 */
export interface Task {
    /**
     * 
     * @type {number}
     * @memberof Task
     */
    'teacher_user_id': number;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'teacher_role': string;
    /**
     * 
     * @type {number}
     * @memberof Task
     */
    'teacher_discipline_id': number;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'create_date'?: string;
    /**
     * 
     * @type {number}
     * @memberof Task
     */
    'id'?: number;
}
/**
 * 
 * @export
 * @interface TaskCreate
 */
export interface TaskCreate {
    /**
     * 
     * @type {number}
     * @memberof TaskCreate
     */
    'teacher_user_id': number;
    /**
     * 
     * @type {string}
     * @memberof TaskCreate
     */
    'teacher_role': string;
    /**
     * 
     * @type {number}
     * @memberof TaskCreate
     */
    'teacher_discipline_id': number;
    /**
     * 
     * @type {string}
     * @memberof TaskCreate
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof TaskCreate
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskCreate
     */
    'create_date'?: string;
}
/**
 * 
 * @export
 * @interface TaskUpdate
 */
export interface TaskUpdate {
    /**
     * 
     * @type {number}
     * @memberof TaskUpdate
     */
    'teacher_user_id': number;
    /**
     * 
     * @type {string}
     * @memberof TaskUpdate
     */
    'teacher_role': string;
    /**
     * 
     * @type {number}
     * @memberof TaskUpdate
     */
    'teacher_discipline_id': number;
    /**
     * 
     * @type {string}
     * @memberof TaskUpdate
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof TaskUpdate
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskUpdate
     */
    'create_date'?: string;
}
/**
 * 
 * @export
 * @interface Teacher
 */
export interface Teacher {
    /**
     * 
     * @type {number}
     * @memberof Teacher
     */
    'user_id': number;
    /**
     * 
     * @type {string}
     * @memberof Teacher
     */
    'role': string;
    /**
     * 
     * @type {number | Array<any>}
     * @memberof Teacher
     */
    'discipline_id': number | Array<any>;
    /**
     * 
     * @type {string}
     * @memberof Teacher
     */
    'room_number'?: string;
    /**
     * 
     * @type {string}
     * @memberof Teacher
     */
    'campus_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof Teacher
     */
    'id'?: number;
}
/**
 * 
 * @export
 * @interface TeacherUpdate
 */
export interface TeacherUpdate {
    /**
     * 
     * @type {number}
     * @memberof TeacherUpdate
     */
    'user_id': number;
    /**
     * 
     * @type {string}
     * @memberof TeacherUpdate
     */
    'role': string;
    /**
     * 
     * @type {number | Array<any>}
     * @memberof TeacherUpdate
     */
    'discipline_id': number | Array<any>;
    /**
     * 
     * @type {string}
     * @memberof TeacherUpdate
     */
    'room_number'?: string;
    /**
     * 
     * @type {string}
     * @memberof TeacherUpdate
     */
    'campus_id'?: string;
}
/**
 * 
 * @export
 * @interface Token
 */
export interface Token {
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    'access_token'?: string;
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    'expires_delta'?: string;
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    'token_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    'sub'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Token
     */
    'scopes'?: Array<string>;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'role': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'full_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'age'?: number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'avatar'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'phone'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'is_superuser'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'id'?: number;
}
/**
 * 
 * @export
 * @interface UserCreate
 */
export interface UserCreate {
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    'role': string;
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    'full_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserCreate
     */
    'age'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    'avatar'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    'phone'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserCreate
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserCreate
     */
    'is_superuser'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface UserUpdate
 */
export interface UserUpdate {
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'role': string;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'full_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserUpdate
     */
    'age'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'avatar'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'phone'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserUpdate
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserUpdate
     */
    'is_superuser'?: boolean;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<string | number>}
     * @memberof ValidationError
     */
    'loc': Array<string | number>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}

/**
 * CampusesApi - axios parameter creator
 * @export
 */
export const CampusesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new Campus.
         * @summary Create Campus
         * @param {CampusCreate} campusCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCampus: async (campusCreate: CampusCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campusCreate' is not null or undefined
            assertParamExists('createCampus', 'campusCreate', campusCreate)
            const localVarPath = `/api/v1/campuses/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(campusCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an Campus.
         * @summary Delete Campus Id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCampusId: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCampusId', 'id', id)
            const localVarPath = `/api/v1/campuses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Campus by ID.
         * @summary Read Campus Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readCampusId: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readCampusId', 'id', id)
            const localVarPath = `/api/v1/campuses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve Campuss.
         * @summary Read Campuss
         * @param {string} [sort] Format: &#x60;[\&quot;field_name\&quot;, \&quot;direction\&quot;]&#x60;
         * @param {string} [range] Format: &#x60;[start, end]&#x60;
         * @param {string} [filter] Format: &#x60;{\&quot;id\&quot;: 0}&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readCampuss: async (sort?: string, range?: string, filter?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/campuses/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (range !== undefined) {
                localVarQueryParameter['range'] = range;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an Campus.
         * @summary Update Campus Id
         * @param {number} id 
         * @param {CampusUpdate} campusUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCampusId: async (id: number, campusUpdate: CampusUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateCampusId', 'id', id)
            // verify required parameter 'campusUpdate' is not null or undefined
            assertParamExists('updateCampusId', 'campusUpdate', campusUpdate)
            const localVarPath = `/api/v1/campuses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(campusUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CampusesApi - functional programming interface
 * @export
 */
export const CampusesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CampusesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new Campus.
         * @summary Create Campus
         * @param {CampusCreate} campusCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCampus(campusCreate: CampusCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Campus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCampus(campusCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an Campus.
         * @summary Delete Campus Id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCampusId(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Campus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCampusId(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Campus by ID.
         * @summary Read Campus Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readCampusId(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Campus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readCampusId(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve Campuss.
         * @summary Read Campuss
         * @param {string} [sort] Format: &#x60;[\&quot;field_name\&quot;, \&quot;direction\&quot;]&#x60;
         * @param {string} [range] Format: &#x60;[start, end]&#x60;
         * @param {string} [filter] Format: &#x60;{\&quot;id\&quot;: 0}&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readCampuss(sort?: string, range?: string, filter?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Campus>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readCampuss(sort, range, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an Campus.
         * @summary Update Campus Id
         * @param {number} id 
         * @param {CampusUpdate} campusUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCampusId(id: number, campusUpdate: CampusUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Campus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCampusId(id, campusUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CampusesApi - factory interface
 * @export
 */
export const CampusesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CampusesApiFp(configuration)
    return {
        /**
         * Create new Campus.
         * @summary Create Campus
         * @param {CampusCreate} campusCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCampus(campusCreate: CampusCreate, options?: any): AxiosPromise<Campus> {
            return localVarFp.createCampus(campusCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an Campus.
         * @summary Delete Campus Id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCampusId(id: number, options?: any): AxiosPromise<Campus> {
            return localVarFp.deleteCampusId(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Campus by ID.
         * @summary Read Campus Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readCampusId(id: string, options?: any): AxiosPromise<Campus> {
            return localVarFp.readCampusId(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve Campuss.
         * @summary Read Campuss
         * @param {string} [sort] Format: &#x60;[\&quot;field_name\&quot;, \&quot;direction\&quot;]&#x60;
         * @param {string} [range] Format: &#x60;[start, end]&#x60;
         * @param {string} [filter] Format: &#x60;{\&quot;id\&quot;: 0}&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readCampuss(sort?: string, range?: string, filter?: string, options?: any): AxiosPromise<Array<Campus>> {
            return localVarFp.readCampuss(sort, range, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an Campus.
         * @summary Update Campus Id
         * @param {number} id 
         * @param {CampusUpdate} campusUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCampusId(id: number, campusUpdate: CampusUpdate, options?: any): AxiosPromise<Campus> {
            return localVarFp.updateCampusId(id, campusUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CampusesApi - object-oriented interface
 * @export
 * @class CampusesApi
 * @extends {BaseAPI}
 */
export class CampusesApi extends BaseAPI {
    /**
     * Create new Campus.
     * @summary Create Campus
     * @param {CampusCreate} campusCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampusesApi
     */
    public createCampus(campusCreate: CampusCreate, options?: AxiosRequestConfig) {
        return CampusesApiFp(this.configuration).createCampus(campusCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an Campus.
     * @summary Delete Campus Id
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampusesApi
     */
    public deleteCampusId(id: number, options?: AxiosRequestConfig) {
        return CampusesApiFp(this.configuration).deleteCampusId(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Campus by ID.
     * @summary Read Campus Id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampusesApi
     */
    public readCampusId(id: string, options?: AxiosRequestConfig) {
        return CampusesApiFp(this.configuration).readCampusId(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve Campuss.
     * @summary Read Campuss
     * @param {string} [sort] Format: &#x60;[\&quot;field_name\&quot;, \&quot;direction\&quot;]&#x60;
     * @param {string} [range] Format: &#x60;[start, end]&#x60;
     * @param {string} [filter] Format: &#x60;{\&quot;id\&quot;: 0}&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampusesApi
     */
    public readCampuss(sort?: string, range?: string, filter?: string, options?: AxiosRequestConfig) {
        return CampusesApiFp(this.configuration).readCampuss(sort, range, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an Campus.
     * @summary Update Campus Id
     * @param {number} id 
     * @param {CampusUpdate} campusUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampusesApi
     */
    public updateCampusId(id: number, campusUpdate: CampusUpdate, options?: AxiosRequestConfig) {
        return CampusesApiFp(this.configuration).updateCampusId(id, campusUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ClassifiersApi - axios parameter creator
 * @export
 */
export const ClassifiersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Read Classifiers
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readClassifiers: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('readClassifiers', 'name', name)
            const localVarPath = `/api/v1/classifiers/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClassifiersApi - functional programming interface
 * @export
 */
export const ClassifiersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClassifiersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Read Classifiers
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readClassifiers(name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readClassifiers(name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ClassifiersApi - factory interface
 * @export
 */
export const ClassifiersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClassifiersApiFp(configuration)
    return {
        /**
         * 
         * @summary Read Classifiers
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readClassifiers(name: string, options?: any): AxiosPromise<any> {
            return localVarFp.readClassifiers(name, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClassifiersApi - object-oriented interface
 * @export
 * @class ClassifiersApi
 * @extends {BaseAPI}
 */
export class ClassifiersApi extends BaseAPI {
    /**
     * 
     * @summary Read Classifiers
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassifiersApi
     */
    public readClassifiers(name: string, options?: AxiosRequestConfig) {
        return ClassifiersApiFp(this.configuration).readClassifiers(name, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Root
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Root
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rootGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rootGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Root
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootGet(options?: any): AxiosPromise<any> {
            return localVarFp.rootGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Root
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public rootGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).rootGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DisciplinesApi - axios parameter creator
 * @export
 */
export const DisciplinesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new Discipline.
         * @summary Create Discipline
         * @param {DisciplineCreate} disciplineCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDiscipline: async (disciplineCreate: DisciplineCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'disciplineCreate' is not null or undefined
            assertParamExists('createDiscipline', 'disciplineCreate', disciplineCreate)
            const localVarPath = `/api/v1/disciplines/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(disciplineCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an Discipline.
         * @summary Delete Discipline Id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDisciplineId: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteDisciplineId', 'id', id)
            const localVarPath = `/api/v1/disciplines/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Discipline by ID.
         * @summary Read Discipline Id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readDisciplineId: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readDisciplineId', 'id', id)
            const localVarPath = `/api/v1/disciplines/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve Tasks.
         * @summary Read Disciplines
         * @param {string} [sort] Format: &#x60;[\&quot;field_name\&quot;, \&quot;direction\&quot;]&#x60;
         * @param {string} [range] Format: &#x60;[start, end]&#x60;
         * @param {string} [filter] Format: &#x60;{\&quot;id\&quot;: 0}&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readDisciplines: async (sort?: string, range?: string, filter?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/disciplines/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (range !== undefined) {
                localVarQueryParameter['range'] = range;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an Discipline.
         * @summary Update Discipline Id
         * @param {number} id 
         * @param {DisciplineUpdate} disciplineUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDisciplineId: async (id: number, disciplineUpdate: DisciplineUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDisciplineId', 'id', id)
            // verify required parameter 'disciplineUpdate' is not null or undefined
            assertParamExists('updateDisciplineId', 'disciplineUpdate', disciplineUpdate)
            const localVarPath = `/api/v1/disciplines/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(disciplineUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DisciplinesApi - functional programming interface
 * @export
 */
export const DisciplinesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DisciplinesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new Discipline.
         * @summary Create Discipline
         * @param {DisciplineCreate} disciplineCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDiscipline(disciplineCreate: DisciplineCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Discipline>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDiscipline(disciplineCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an Discipline.
         * @summary Delete Discipline Id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDisciplineId(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Discipline>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDisciplineId(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Discipline by ID.
         * @summary Read Discipline Id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readDisciplineId(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Discipline>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readDisciplineId(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve Tasks.
         * @summary Read Disciplines
         * @param {string} [sort] Format: &#x60;[\&quot;field_name\&quot;, \&quot;direction\&quot;]&#x60;
         * @param {string} [range] Format: &#x60;[start, end]&#x60;
         * @param {string} [filter] Format: &#x60;{\&quot;id\&quot;: 0}&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readDisciplines(sort?: string, range?: string, filter?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Discipline>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readDisciplines(sort, range, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an Discipline.
         * @summary Update Discipline Id
         * @param {number} id 
         * @param {DisciplineUpdate} disciplineUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDisciplineId(id: number, disciplineUpdate: DisciplineUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Discipline>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDisciplineId(id, disciplineUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DisciplinesApi - factory interface
 * @export
 */
export const DisciplinesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DisciplinesApiFp(configuration)
    return {
        /**
         * Create new Discipline.
         * @summary Create Discipline
         * @param {DisciplineCreate} disciplineCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDiscipline(disciplineCreate: DisciplineCreate, options?: any): AxiosPromise<Discipline> {
            return localVarFp.createDiscipline(disciplineCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an Discipline.
         * @summary Delete Discipline Id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDisciplineId(id: number, options?: any): AxiosPromise<Discipline> {
            return localVarFp.deleteDisciplineId(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Discipline by ID.
         * @summary Read Discipline Id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readDisciplineId(id: number, options?: any): AxiosPromise<Discipline> {
            return localVarFp.readDisciplineId(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve Tasks.
         * @summary Read Disciplines
         * @param {string} [sort] Format: &#x60;[\&quot;field_name\&quot;, \&quot;direction\&quot;]&#x60;
         * @param {string} [range] Format: &#x60;[start, end]&#x60;
         * @param {string} [filter] Format: &#x60;{\&quot;id\&quot;: 0}&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readDisciplines(sort?: string, range?: string, filter?: string, options?: any): AxiosPromise<Array<Discipline>> {
            return localVarFp.readDisciplines(sort, range, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an Discipline.
         * @summary Update Discipline Id
         * @param {number} id 
         * @param {DisciplineUpdate} disciplineUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDisciplineId(id: number, disciplineUpdate: DisciplineUpdate, options?: any): AxiosPromise<Discipline> {
            return localVarFp.updateDisciplineId(id, disciplineUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DisciplinesApi - object-oriented interface
 * @export
 * @class DisciplinesApi
 * @extends {BaseAPI}
 */
export class DisciplinesApi extends BaseAPI {
    /**
     * Create new Discipline.
     * @summary Create Discipline
     * @param {DisciplineCreate} disciplineCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisciplinesApi
     */
    public createDiscipline(disciplineCreate: DisciplineCreate, options?: AxiosRequestConfig) {
        return DisciplinesApiFp(this.configuration).createDiscipline(disciplineCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an Discipline.
     * @summary Delete Discipline Id
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisciplinesApi
     */
    public deleteDisciplineId(id: number, options?: AxiosRequestConfig) {
        return DisciplinesApiFp(this.configuration).deleteDisciplineId(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Discipline by ID.
     * @summary Read Discipline Id
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisciplinesApi
     */
    public readDisciplineId(id: number, options?: AxiosRequestConfig) {
        return DisciplinesApiFp(this.configuration).readDisciplineId(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve Tasks.
     * @summary Read Disciplines
     * @param {string} [sort] Format: &#x60;[\&quot;field_name\&quot;, \&quot;direction\&quot;]&#x60;
     * @param {string} [range] Format: &#x60;[start, end]&#x60;
     * @param {string} [filter] Format: &#x60;{\&quot;id\&quot;: 0}&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisciplinesApi
     */
    public readDisciplines(sort?: string, range?: string, filter?: string, options?: AxiosRequestConfig) {
        return DisciplinesApiFp(this.configuration).readDisciplines(sort, range, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an Discipline.
     * @summary Update Discipline Id
     * @param {number} id 
     * @param {DisciplineUpdate} disciplineUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisciplinesApi
     */
    public updateDisciplineId(id: number, disciplineUpdate: DisciplineUpdate, options?: AxiosRequestConfig) {
        return DisciplinesApiFp(this.configuration).updateDisciplineId(id, disciplineUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LoginApi - axios parameter creator
 * @export
 */
export const LoginApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * OAuth2 compatible token login, get an access token for future requests
         * @summary Login Access Token
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginAccessToken: async (username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('loginAccessToken', 'username', username)
            // verify required parameter 'password' is not null or undefined
            assertParamExists('loginAccessToken', 'password', password)
            const localVarPath = `/api/v1/login/access-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (grantType !== undefined) { 
                localVarFormParams.set('grant_type', grantType as any);
            }
    
            if (username !== undefined) { 
                localVarFormParams.set('username', username as any);
            }
    
            if (password !== undefined) { 
                localVarFormParams.set('password', password as any);
            }
    
            if (scope !== undefined) { 
                localVarFormParams.set('scope', scope as any);
            }
    
            if (clientId !== undefined) { 
                localVarFormParams.set('client_id', clientId as any);
            }
    
            if (clientSecret !== undefined) { 
                localVarFormParams.set('client_secret', clientSecret as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LoginApi - functional programming interface
 * @export
 */
export const LoginApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LoginApiAxiosParamCreator(configuration)
    return {
        /**
         * OAuth2 compatible token login, get an access token for future requests
         * @summary Login Access Token
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginAccessToken(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginAccessToken(username, password, grantType, scope, clientId, clientSecret, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LoginApi - factory interface
 * @export
 */
export const LoginApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LoginApiFp(configuration)
    return {
        /**
         * OAuth2 compatible token login, get an access token for future requests
         * @summary Login Access Token
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginAccessToken(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options?: any): AxiosPromise<Token> {
            return localVarFp.loginAccessToken(username, password, grantType, scope, clientId, clientSecret, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LoginApi - object-oriented interface
 * @export
 * @class LoginApi
 * @extends {BaseAPI}
 */
export class LoginApi extends BaseAPI {
    /**
     * OAuth2 compatible token login, get an access token for future requests
     * @summary Login Access Token
     * @param {string} username 
     * @param {string} password 
     * @param {string} [grantType] 
     * @param {string} [scope] 
     * @param {string} [clientId] 
     * @param {string} [clientSecret] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginApi
     */
    public loginAccessToken(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options?: AxiosRequestConfig) {
        return LoginApiFp(this.configuration).loginAccessToken(username, password, grantType, scope, clientId, clientSecret, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StudentTaskStoresApi - axios parameter creator
 * @export
 */
export const StudentTaskStoresApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new task_store.
         * @summary Create Task Store
         * @param {StudentTaskStoreCreate} studentTaskStoreCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTaskStore: async (studentTaskStoreCreate: StudentTaskStoreCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studentTaskStoreCreate' is not null or undefined
            assertParamExists('createTaskStore', 'studentTaskStoreCreate', studentTaskStoreCreate)
            const localVarPath = `/api/v1/student_task_stores/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(studentTaskStoreCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an task_store.
         * @summary Delete Task Store
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaskStore: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTaskStore', 'id', id)
            const localVarPath = `/api/v1/student_task_stores/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get task_store by ID.
         * @summary Read Task Store
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readTaskStore: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readTaskStore', 'id', id)
            const localVarPath = `/api/v1/student_task_stores/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve StudentTaskStores.
         * @summary Read Task Stores
         * @param {string} [sort] Format: &#x60;[\&quot;field_name\&quot;, \&quot;direction\&quot;]&#x60;
         * @param {string} [range] Format: &#x60;[start, end]&#x60;
         * @param {string} [filter] Format: &#x60;{\&quot;id\&quot;: 0}&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readTaskStores: async (sort?: string, range?: string, filter?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/student_task_stores/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (range !== undefined) {
                localVarQueryParameter['range'] = range;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an task_store.
         * @summary Update Task Store
         * @param {number} id 
         * @param {StudentTaskStoreUpdate} studentTaskStoreUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaskStore: async (id: number, studentTaskStoreUpdate: StudentTaskStoreUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTaskStore', 'id', id)
            // verify required parameter 'studentTaskStoreUpdate' is not null or undefined
            assertParamExists('updateTaskStore', 'studentTaskStoreUpdate', studentTaskStoreUpdate)
            const localVarPath = `/api/v1/student_task_stores/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(studentTaskStoreUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StudentTaskStoresApi - functional programming interface
 * @export
 */
export const StudentTaskStoresApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StudentTaskStoresApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new task_store.
         * @summary Create Task Store
         * @param {StudentTaskStoreCreate} studentTaskStoreCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTaskStore(studentTaskStoreCreate: StudentTaskStoreCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentTaskStore>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTaskStore(studentTaskStoreCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an task_store.
         * @summary Delete Task Store
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTaskStore(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentTaskStore>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTaskStore(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get task_store by ID.
         * @summary Read Task Store
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readTaskStore(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentTaskStore>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readTaskStore(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve StudentTaskStores.
         * @summary Read Task Stores
         * @param {string} [sort] Format: &#x60;[\&quot;field_name\&quot;, \&quot;direction\&quot;]&#x60;
         * @param {string} [range] Format: &#x60;[start, end]&#x60;
         * @param {string} [filter] Format: &#x60;{\&quot;id\&quot;: 0}&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readTaskStores(sort?: string, range?: string, filter?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StudentTaskStore>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readTaskStores(sort, range, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an task_store.
         * @summary Update Task Store
         * @param {number} id 
         * @param {StudentTaskStoreUpdate} studentTaskStoreUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTaskStore(id: number, studentTaskStoreUpdate: StudentTaskStoreUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentTaskStore>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTaskStore(id, studentTaskStoreUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StudentTaskStoresApi - factory interface
 * @export
 */
export const StudentTaskStoresApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StudentTaskStoresApiFp(configuration)
    return {
        /**
         * Create new task_store.
         * @summary Create Task Store
         * @param {StudentTaskStoreCreate} studentTaskStoreCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTaskStore(studentTaskStoreCreate: StudentTaskStoreCreate, options?: any): AxiosPromise<StudentTaskStore> {
            return localVarFp.createTaskStore(studentTaskStoreCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an task_store.
         * @summary Delete Task Store
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaskStore(id: number, options?: any): AxiosPromise<StudentTaskStore> {
            return localVarFp.deleteTaskStore(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get task_store by ID.
         * @summary Read Task Store
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readTaskStore(id: number, options?: any): AxiosPromise<StudentTaskStore> {
            return localVarFp.readTaskStore(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve StudentTaskStores.
         * @summary Read Task Stores
         * @param {string} [sort] Format: &#x60;[\&quot;field_name\&quot;, \&quot;direction\&quot;]&#x60;
         * @param {string} [range] Format: &#x60;[start, end]&#x60;
         * @param {string} [filter] Format: &#x60;{\&quot;id\&quot;: 0}&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readTaskStores(sort?: string, range?: string, filter?: string, options?: any): AxiosPromise<Array<StudentTaskStore>> {
            return localVarFp.readTaskStores(sort, range, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an task_store.
         * @summary Update Task Store
         * @param {number} id 
         * @param {StudentTaskStoreUpdate} studentTaskStoreUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaskStore(id: number, studentTaskStoreUpdate: StudentTaskStoreUpdate, options?: any): AxiosPromise<StudentTaskStore> {
            return localVarFp.updateTaskStore(id, studentTaskStoreUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StudentTaskStoresApi - object-oriented interface
 * @export
 * @class StudentTaskStoresApi
 * @extends {BaseAPI}
 */
export class StudentTaskStoresApi extends BaseAPI {
    /**
     * Create new task_store.
     * @summary Create Task Store
     * @param {StudentTaskStoreCreate} studentTaskStoreCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentTaskStoresApi
     */
    public createTaskStore(studentTaskStoreCreate: StudentTaskStoreCreate, options?: AxiosRequestConfig) {
        return StudentTaskStoresApiFp(this.configuration).createTaskStore(studentTaskStoreCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an task_store.
     * @summary Delete Task Store
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentTaskStoresApi
     */
    public deleteTaskStore(id: number, options?: AxiosRequestConfig) {
        return StudentTaskStoresApiFp(this.configuration).deleteTaskStore(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get task_store by ID.
     * @summary Read Task Store
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentTaskStoresApi
     */
    public readTaskStore(id: number, options?: AxiosRequestConfig) {
        return StudentTaskStoresApiFp(this.configuration).readTaskStore(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve StudentTaskStores.
     * @summary Read Task Stores
     * @param {string} [sort] Format: &#x60;[\&quot;field_name\&quot;, \&quot;direction\&quot;]&#x60;
     * @param {string} [range] Format: &#x60;[start, end]&#x60;
     * @param {string} [filter] Format: &#x60;{\&quot;id\&quot;: 0}&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentTaskStoresApi
     */
    public readTaskStores(sort?: string, range?: string, filter?: string, options?: AxiosRequestConfig) {
        return StudentTaskStoresApiFp(this.configuration).readTaskStores(sort, range, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an task_store.
     * @summary Update Task Store
     * @param {number} id 
     * @param {StudentTaskStoreUpdate} studentTaskStoreUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentTaskStoresApi
     */
    public updateTaskStore(id: number, studentTaskStoreUpdate: StudentTaskStoreUpdate, options?: AxiosRequestConfig) {
        return StudentTaskStoresApiFp(this.configuration).updateTaskStore(id, studentTaskStoreUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StudentTasksApi - axios parameter creator
 * @export
 */
export const StudentTasksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new task.
         * @summary Create Task Student
         * @param {StudentTaskCreate} studentTaskCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTaskStudent: async (studentTaskCreate: StudentTaskCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studentTaskCreate' is not null or undefined
            assertParamExists('createTaskStudent', 'studentTaskCreate', studentTaskCreate)
            const localVarPath = `/api/v1/student_tasks/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(studentTaskCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an task.
         * @summary Delete Task Student Id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaskStudentId: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTaskStudentId', 'id', id)
            const localVarPath = `/api/v1/student_tasks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get task by ID.
         * @summary Read Task Student Id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readTaskStudentId: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readTaskStudentId', 'id', id)
            const localVarPath = `/api/v1/student_tasks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve Tasks.
         * @summary Read Task Students
         * @param {string} [sort] Format: &#x60;[\&quot;field_name\&quot;, \&quot;direction\&quot;]&#x60;
         * @param {string} [range] Format: &#x60;[start, end]&#x60;
         * @param {string} [filter] Format: &#x60;{\&quot;id\&quot;: 0}&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readTaskStudents: async (sort?: string, range?: string, filter?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/student_tasks/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (range !== undefined) {
                localVarQueryParameter['range'] = range;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an task.
         * @summary Update Task Student Id
         * @param {number} id 
         * @param {StudentTaskUpdate} studentTaskUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaskStudentId: async (id: number, studentTaskUpdate: StudentTaskUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTaskStudentId', 'id', id)
            // verify required parameter 'studentTaskUpdate' is not null or undefined
            assertParamExists('updateTaskStudentId', 'studentTaskUpdate', studentTaskUpdate)
            const localVarPath = `/api/v1/student_tasks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(studentTaskUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StudentTasksApi - functional programming interface
 * @export
 */
export const StudentTasksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StudentTasksApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new task.
         * @summary Create Task Student
         * @param {StudentTaskCreate} studentTaskCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTaskStudent(studentTaskCreate: StudentTaskCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentTask>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTaskStudent(studentTaskCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an task.
         * @summary Delete Task Student Id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTaskStudentId(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentTask>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTaskStudentId(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get task by ID.
         * @summary Read Task Student Id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readTaskStudentId(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentTask>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readTaskStudentId(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve Tasks.
         * @summary Read Task Students
         * @param {string} [sort] Format: &#x60;[\&quot;field_name\&quot;, \&quot;direction\&quot;]&#x60;
         * @param {string} [range] Format: &#x60;[start, end]&#x60;
         * @param {string} [filter] Format: &#x60;{\&quot;id\&quot;: 0}&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readTaskStudents(sort?: string, range?: string, filter?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StudentTask>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readTaskStudents(sort, range, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an task.
         * @summary Update Task Student Id
         * @param {number} id 
         * @param {StudentTaskUpdate} studentTaskUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTaskStudentId(id: number, studentTaskUpdate: StudentTaskUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentTask>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTaskStudentId(id, studentTaskUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StudentTasksApi - factory interface
 * @export
 */
export const StudentTasksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StudentTasksApiFp(configuration)
    return {
        /**
         * Create new task.
         * @summary Create Task Student
         * @param {StudentTaskCreate} studentTaskCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTaskStudent(studentTaskCreate: StudentTaskCreate, options?: any): AxiosPromise<StudentTask> {
            return localVarFp.createTaskStudent(studentTaskCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an task.
         * @summary Delete Task Student Id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaskStudentId(id: number, options?: any): AxiosPromise<StudentTask> {
            return localVarFp.deleteTaskStudentId(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get task by ID.
         * @summary Read Task Student Id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readTaskStudentId(id: number, options?: any): AxiosPromise<StudentTask> {
            return localVarFp.readTaskStudentId(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve Tasks.
         * @summary Read Task Students
         * @param {string} [sort] Format: &#x60;[\&quot;field_name\&quot;, \&quot;direction\&quot;]&#x60;
         * @param {string} [range] Format: &#x60;[start, end]&#x60;
         * @param {string} [filter] Format: &#x60;{\&quot;id\&quot;: 0}&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readTaskStudents(sort?: string, range?: string, filter?: string, options?: any): AxiosPromise<Array<StudentTask>> {
            return localVarFp.readTaskStudents(sort, range, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an task.
         * @summary Update Task Student Id
         * @param {number} id 
         * @param {StudentTaskUpdate} studentTaskUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaskStudentId(id: number, studentTaskUpdate: StudentTaskUpdate, options?: any): AxiosPromise<StudentTask> {
            return localVarFp.updateTaskStudentId(id, studentTaskUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StudentTasksApi - object-oriented interface
 * @export
 * @class StudentTasksApi
 * @extends {BaseAPI}
 */
export class StudentTasksApi extends BaseAPI {
    /**
     * Create new task.
     * @summary Create Task Student
     * @param {StudentTaskCreate} studentTaskCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentTasksApi
     */
    public createTaskStudent(studentTaskCreate: StudentTaskCreate, options?: AxiosRequestConfig) {
        return StudentTasksApiFp(this.configuration).createTaskStudent(studentTaskCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an task.
     * @summary Delete Task Student Id
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentTasksApi
     */
    public deleteTaskStudentId(id: number, options?: AxiosRequestConfig) {
        return StudentTasksApiFp(this.configuration).deleteTaskStudentId(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get task by ID.
     * @summary Read Task Student Id
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentTasksApi
     */
    public readTaskStudentId(id: number, options?: AxiosRequestConfig) {
        return StudentTasksApiFp(this.configuration).readTaskStudentId(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve Tasks.
     * @summary Read Task Students
     * @param {string} [sort] Format: &#x60;[\&quot;field_name\&quot;, \&quot;direction\&quot;]&#x60;
     * @param {string} [range] Format: &#x60;[start, end]&#x60;
     * @param {string} [filter] Format: &#x60;{\&quot;id\&quot;: 0}&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentTasksApi
     */
    public readTaskStudents(sort?: string, range?: string, filter?: string, options?: AxiosRequestConfig) {
        return StudentTasksApiFp(this.configuration).readTaskStudents(sort, range, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an task.
     * @summary Update Task Student Id
     * @param {number} id 
     * @param {StudentTaskUpdate} studentTaskUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentTasksApi
     */
    public updateTaskStudentId(id: number, studentTaskUpdate: StudentTaskUpdate, options?: AxiosRequestConfig) {
        return StudentTasksApiFp(this.configuration).updateTaskStudentId(id, studentTaskUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StudentsApi - axios parameter creator
 * @export
 */
export const StudentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new Student.
         * @summary Create Student
         * @param {UserCreate} userCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStudent: async (userCreate: UserCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreate' is not null or undefined
            assertParamExists('createStudent', 'userCreate', userCreate)
            const localVarPath = `/api/v1/students/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Student.
         * @summary Delete Student Id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStudentId: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteStudentId', 'id', id)
            const localVarPath = `/api/v1/students/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Student by ID.
         * @summary Read Student Id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readStudentId: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readStudentId', 'id', id)
            const localVarPath = `/api/v1/students/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve Tasks.
         * @summary Read Students
         * @param {string} [sort] Format: &#x60;[\&quot;field_name\&quot;, \&quot;direction\&quot;]&#x60;
         * @param {string} [range] Format: &#x60;[start, end]&#x60;
         * @param {string} [filter] Format: &#x60;{\&quot;id\&quot;: 0}&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readStudents: async (sort?: string, range?: string, filter?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/students/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (range !== undefined) {
                localVarQueryParameter['range'] = range;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Student.
         * @summary Update Student Id
         * @param {number} id 
         * @param {StudentUpdate} studentUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStudentId: async (id: number, studentUpdate: StudentUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateStudentId', 'id', id)
            // verify required parameter 'studentUpdate' is not null or undefined
            assertParamExists('updateStudentId', 'studentUpdate', studentUpdate)
            const localVarPath = `/api/v1/students/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(studentUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StudentsApi - functional programming interface
 * @export
 */
export const StudentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StudentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new Student.
         * @summary Create Student
         * @param {UserCreate} userCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createStudent(userCreate: UserCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Student>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createStudent(userCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a Student.
         * @summary Delete Student Id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteStudentId(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Student>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteStudentId(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Student by ID.
         * @summary Read Student Id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readStudentId(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Student>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readStudentId(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve Tasks.
         * @summary Read Students
         * @param {string} [sort] Format: &#x60;[\&quot;field_name\&quot;, \&quot;direction\&quot;]&#x60;
         * @param {string} [range] Format: &#x60;[start, end]&#x60;
         * @param {string} [filter] Format: &#x60;{\&quot;id\&quot;: 0}&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readStudents(sort?: string, range?: string, filter?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Student>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readStudents(sort, range, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a Student.
         * @summary Update Student Id
         * @param {number} id 
         * @param {StudentUpdate} studentUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateStudentId(id: number, studentUpdate: StudentUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Student>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateStudentId(id, studentUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StudentsApi - factory interface
 * @export
 */
export const StudentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StudentsApiFp(configuration)
    return {
        /**
         * Create new Student.
         * @summary Create Student
         * @param {UserCreate} userCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStudent(userCreate: UserCreate, options?: any): AxiosPromise<Student> {
            return localVarFp.createStudent(userCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Student.
         * @summary Delete Student Id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStudentId(id: number, options?: any): AxiosPromise<Student> {
            return localVarFp.deleteStudentId(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Student by ID.
         * @summary Read Student Id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readStudentId(id: number, options?: any): AxiosPromise<Student> {
            return localVarFp.readStudentId(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve Tasks.
         * @summary Read Students
         * @param {string} [sort] Format: &#x60;[\&quot;field_name\&quot;, \&quot;direction\&quot;]&#x60;
         * @param {string} [range] Format: &#x60;[start, end]&#x60;
         * @param {string} [filter] Format: &#x60;{\&quot;id\&quot;: 0}&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readStudents(sort?: string, range?: string, filter?: string, options?: any): AxiosPromise<Array<Student>> {
            return localVarFp.readStudents(sort, range, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Student.
         * @summary Update Student Id
         * @param {number} id 
         * @param {StudentUpdate} studentUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStudentId(id: number, studentUpdate: StudentUpdate, options?: any): AxiosPromise<Student> {
            return localVarFp.updateStudentId(id, studentUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StudentsApi - object-oriented interface
 * @export
 * @class StudentsApi
 * @extends {BaseAPI}
 */
export class StudentsApi extends BaseAPI {
    /**
     * Create new Student.
     * @summary Create Student
     * @param {UserCreate} userCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentsApi
     */
    public createStudent(userCreate: UserCreate, options?: AxiosRequestConfig) {
        return StudentsApiFp(this.configuration).createStudent(userCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a Student.
     * @summary Delete Student Id
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentsApi
     */
    public deleteStudentId(id: number, options?: AxiosRequestConfig) {
        return StudentsApiFp(this.configuration).deleteStudentId(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Student by ID.
     * @summary Read Student Id
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentsApi
     */
    public readStudentId(id: number, options?: AxiosRequestConfig) {
        return StudentsApiFp(this.configuration).readStudentId(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve Tasks.
     * @summary Read Students
     * @param {string} [sort] Format: &#x60;[\&quot;field_name\&quot;, \&quot;direction\&quot;]&#x60;
     * @param {string} [range] Format: &#x60;[start, end]&#x60;
     * @param {string} [filter] Format: &#x60;{\&quot;id\&quot;: 0}&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentsApi
     */
    public readStudents(sort?: string, range?: string, filter?: string, options?: AxiosRequestConfig) {
        return StudentsApiFp(this.configuration).readStudents(sort, range, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a Student.
     * @summary Update Student Id
     * @param {number} id 
     * @param {StudentUpdate} studentUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudentsApi
     */
    public updateStudentId(id: number, studentUpdate: StudentUpdate, options?: AxiosRequestConfig) {
        return StudentsApiFp(this.configuration).updateStudentId(id, studentUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StudyGroupCiphersApi - axios parameter creator
 * @export
 */
export const StudyGroupCiphersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new task.
         * @summary Create Study Group Cipher
         * @param {StudyGroupCipherCreate} studyGroupCipherCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStudyGroupCipher: async (studyGroupCipherCreate: StudyGroupCipherCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studyGroupCipherCreate' is not null or undefined
            assertParamExists('createStudyGroupCipher', 'studyGroupCipherCreate', studyGroupCipherCreate)
            const localVarPath = `/api/v1/study_group_ciphers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(studyGroupCipherCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an task.
         * @summary Delete Study Group Cipher Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStudyGroupCipherId: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteStudyGroupCipherId', 'id', id)
            const localVarPath = `/api/v1/study_group_ciphers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get task by ID.
         * @summary Read Study Group Cipher Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readStudyGroupCipherId: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readStudyGroupCipherId', 'id', id)
            const localVarPath = `/api/v1/study_group_ciphers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve StudyGroupCipher.
         * @summary Read Study Group Ciphers
         * @param {string} [sort] Format: &#x60;[\&quot;field_name\&quot;, \&quot;direction\&quot;]&#x60;
         * @param {string} [range] Format: &#x60;[start, end]&#x60;
         * @param {string} [filter] Format: &#x60;{\&quot;id\&quot;: 0}&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readStudyGroupCiphers: async (sort?: string, range?: string, filter?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/study_group_ciphers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (range !== undefined) {
                localVarQueryParameter['range'] = range;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an task.
         * @summary Update Study Group Cipher Id
         * @param {string} id 
         * @param {StudyGroupCipherUpdate} studyGroupCipherUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStudyGroupCipherId: async (id: string, studyGroupCipherUpdate: StudyGroupCipherUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateStudyGroupCipherId', 'id', id)
            // verify required parameter 'studyGroupCipherUpdate' is not null or undefined
            assertParamExists('updateStudyGroupCipherId', 'studyGroupCipherUpdate', studyGroupCipherUpdate)
            const localVarPath = `/api/v1/study_group_ciphers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(studyGroupCipherUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StudyGroupCiphersApi - functional programming interface
 * @export
 */
export const StudyGroupCiphersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StudyGroupCiphersApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new task.
         * @summary Create Study Group Cipher
         * @param {StudyGroupCipherCreate} studyGroupCipherCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createStudyGroupCipher(studyGroupCipherCreate: StudyGroupCipherCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudyGroupCipher>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createStudyGroupCipher(studyGroupCipherCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an task.
         * @summary Delete Study Group Cipher Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteStudyGroupCipherId(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudyGroupCipher>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteStudyGroupCipherId(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get task by ID.
         * @summary Read Study Group Cipher Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readStudyGroupCipherId(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudyGroupCipher>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readStudyGroupCipherId(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve StudyGroupCipher.
         * @summary Read Study Group Ciphers
         * @param {string} [sort] Format: &#x60;[\&quot;field_name\&quot;, \&quot;direction\&quot;]&#x60;
         * @param {string} [range] Format: &#x60;[start, end]&#x60;
         * @param {string} [filter] Format: &#x60;{\&quot;id\&quot;: 0}&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readStudyGroupCiphers(sort?: string, range?: string, filter?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StudyGroupCipher>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readStudyGroupCiphers(sort, range, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an task.
         * @summary Update Study Group Cipher Id
         * @param {string} id 
         * @param {StudyGroupCipherUpdate} studyGroupCipherUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateStudyGroupCipherId(id: string, studyGroupCipherUpdate: StudyGroupCipherUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudyGroupCipher>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateStudyGroupCipherId(id, studyGroupCipherUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StudyGroupCiphersApi - factory interface
 * @export
 */
export const StudyGroupCiphersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StudyGroupCiphersApiFp(configuration)
    return {
        /**
         * Create new task.
         * @summary Create Study Group Cipher
         * @param {StudyGroupCipherCreate} studyGroupCipherCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStudyGroupCipher(studyGroupCipherCreate: StudyGroupCipherCreate, options?: any): AxiosPromise<StudyGroupCipher> {
            return localVarFp.createStudyGroupCipher(studyGroupCipherCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an task.
         * @summary Delete Study Group Cipher Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStudyGroupCipherId(id: string, options?: any): AxiosPromise<StudyGroupCipher> {
            return localVarFp.deleteStudyGroupCipherId(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get task by ID.
         * @summary Read Study Group Cipher Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readStudyGroupCipherId(id: string, options?: any): AxiosPromise<StudyGroupCipher> {
            return localVarFp.readStudyGroupCipherId(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve StudyGroupCipher.
         * @summary Read Study Group Ciphers
         * @param {string} [sort] Format: &#x60;[\&quot;field_name\&quot;, \&quot;direction\&quot;]&#x60;
         * @param {string} [range] Format: &#x60;[start, end]&#x60;
         * @param {string} [filter] Format: &#x60;{\&quot;id\&quot;: 0}&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readStudyGroupCiphers(sort?: string, range?: string, filter?: string, options?: any): AxiosPromise<Array<StudyGroupCipher>> {
            return localVarFp.readStudyGroupCiphers(sort, range, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an task.
         * @summary Update Study Group Cipher Id
         * @param {string} id 
         * @param {StudyGroupCipherUpdate} studyGroupCipherUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStudyGroupCipherId(id: string, studyGroupCipherUpdate: StudyGroupCipherUpdate, options?: any): AxiosPromise<StudyGroupCipher> {
            return localVarFp.updateStudyGroupCipherId(id, studyGroupCipherUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StudyGroupCiphersApi - object-oriented interface
 * @export
 * @class StudyGroupCiphersApi
 * @extends {BaseAPI}
 */
export class StudyGroupCiphersApi extends BaseAPI {
    /**
     * Create new task.
     * @summary Create Study Group Cipher
     * @param {StudyGroupCipherCreate} studyGroupCipherCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudyGroupCiphersApi
     */
    public createStudyGroupCipher(studyGroupCipherCreate: StudyGroupCipherCreate, options?: AxiosRequestConfig) {
        return StudyGroupCiphersApiFp(this.configuration).createStudyGroupCipher(studyGroupCipherCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an task.
     * @summary Delete Study Group Cipher Id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudyGroupCiphersApi
     */
    public deleteStudyGroupCipherId(id: string, options?: AxiosRequestConfig) {
        return StudyGroupCiphersApiFp(this.configuration).deleteStudyGroupCipherId(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get task by ID.
     * @summary Read Study Group Cipher Id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudyGroupCiphersApi
     */
    public readStudyGroupCipherId(id: string, options?: AxiosRequestConfig) {
        return StudyGroupCiphersApiFp(this.configuration).readStudyGroupCipherId(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve StudyGroupCipher.
     * @summary Read Study Group Ciphers
     * @param {string} [sort] Format: &#x60;[\&quot;field_name\&quot;, \&quot;direction\&quot;]&#x60;
     * @param {string} [range] Format: &#x60;[start, end]&#x60;
     * @param {string} [filter] Format: &#x60;{\&quot;id\&quot;: 0}&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudyGroupCiphersApi
     */
    public readStudyGroupCiphers(sort?: string, range?: string, filter?: string, options?: AxiosRequestConfig) {
        return StudyGroupCiphersApiFp(this.configuration).readStudyGroupCiphers(sort, range, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an task.
     * @summary Update Study Group Cipher Id
     * @param {string} id 
     * @param {StudyGroupCipherUpdate} studyGroupCipherUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudyGroupCiphersApi
     */
    public updateStudyGroupCipherId(id: string, studyGroupCipherUpdate: StudyGroupCipherUpdate, options?: AxiosRequestConfig) {
        return StudyGroupCiphersApiFp(this.configuration).updateStudyGroupCipherId(id, studyGroupCipherUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StudyGroupTasksApi - axios parameter creator
 * @export
 */
export const StudyGroupTasksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete an StudyGroupTask.
         * @summary Delete Study Group Discipline Id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStudyGroupDisciplineId: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteStudyGroupDisciplineId', 'id', id)
            const localVarPath = `/api/v1/study_group_tasks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve StudyGroupTasks.
         * @summary Read Study Group Discipline
         * @param {string} [sort] Format: &#x60;[\&quot;field_name\&quot;, \&quot;direction\&quot;]&#x60;
         * @param {string} [range] Format: &#x60;[start, end]&#x60;
         * @param {string} [filter] Format: &#x60;{\&quot;id\&quot;: 0}&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readStudyGroupDiscipline: async (sort?: string, range?: string, filter?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/study_group_tasks/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (range !== undefined) {
                localVarQueryParameter['range'] = range;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get StudyGroupTask by ID.
         * @summary Read Study Group Discipline Id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readStudyGroupDisciplineId: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readStudyGroupDisciplineId', 'id', id)
            const localVarPath = `/api/v1/study_group_tasks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an StudyGroupTask.
         * @summary Update Study Group Discipline Id
         * @param {number} id 
         * @param {StudyGroupTaskUpdate} studyGroupTaskUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStudyGroupDisciplineId: async (id: number, studyGroupTaskUpdate: StudyGroupTaskUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateStudyGroupDisciplineId', 'id', id)
            // verify required parameter 'studyGroupTaskUpdate' is not null or undefined
            assertParamExists('updateStudyGroupDisciplineId', 'studyGroupTaskUpdate', studyGroupTaskUpdate)
            const localVarPath = `/api/v1/study_group_tasks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(studyGroupTaskUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StudyGroupTasksApi - functional programming interface
 * @export
 */
export const StudyGroupTasksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StudyGroupTasksApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete an StudyGroupTask.
         * @summary Delete Study Group Discipline Id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteStudyGroupDisciplineId(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudyGroupTask>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteStudyGroupDisciplineId(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve StudyGroupTasks.
         * @summary Read Study Group Discipline
         * @param {string} [sort] Format: &#x60;[\&quot;field_name\&quot;, \&quot;direction\&quot;]&#x60;
         * @param {string} [range] Format: &#x60;[start, end]&#x60;
         * @param {string} [filter] Format: &#x60;{\&quot;id\&quot;: 0}&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readStudyGroupDiscipline(sort?: string, range?: string, filter?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StudyGroupTask>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readStudyGroupDiscipline(sort, range, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get StudyGroupTask by ID.
         * @summary Read Study Group Discipline Id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readStudyGroupDisciplineId(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudyGroupTask>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readStudyGroupDisciplineId(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an StudyGroupTask.
         * @summary Update Study Group Discipline Id
         * @param {number} id 
         * @param {StudyGroupTaskUpdate} studyGroupTaskUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateStudyGroupDisciplineId(id: number, studyGroupTaskUpdate: StudyGroupTaskUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudyGroupTask>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateStudyGroupDisciplineId(id, studyGroupTaskUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StudyGroupTasksApi - factory interface
 * @export
 */
export const StudyGroupTasksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StudyGroupTasksApiFp(configuration)
    return {
        /**
         * Delete an StudyGroupTask.
         * @summary Delete Study Group Discipline Id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStudyGroupDisciplineId(id: number, options?: any): AxiosPromise<StudyGroupTask> {
            return localVarFp.deleteStudyGroupDisciplineId(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve StudyGroupTasks.
         * @summary Read Study Group Discipline
         * @param {string} [sort] Format: &#x60;[\&quot;field_name\&quot;, \&quot;direction\&quot;]&#x60;
         * @param {string} [range] Format: &#x60;[start, end]&#x60;
         * @param {string} [filter] Format: &#x60;{\&quot;id\&quot;: 0}&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readStudyGroupDiscipline(sort?: string, range?: string, filter?: string, options?: any): AxiosPromise<Array<StudyGroupTask>> {
            return localVarFp.readStudyGroupDiscipline(sort, range, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Get StudyGroupTask by ID.
         * @summary Read Study Group Discipline Id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readStudyGroupDisciplineId(id: number, options?: any): AxiosPromise<StudyGroupTask> {
            return localVarFp.readStudyGroupDisciplineId(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an StudyGroupTask.
         * @summary Update Study Group Discipline Id
         * @param {number} id 
         * @param {StudyGroupTaskUpdate} studyGroupTaskUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStudyGroupDisciplineId(id: number, studyGroupTaskUpdate: StudyGroupTaskUpdate, options?: any): AxiosPromise<StudyGroupTask> {
            return localVarFp.updateStudyGroupDisciplineId(id, studyGroupTaskUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StudyGroupTasksApi - object-oriented interface
 * @export
 * @class StudyGroupTasksApi
 * @extends {BaseAPI}
 */
export class StudyGroupTasksApi extends BaseAPI {
    /**
     * Delete an StudyGroupTask.
     * @summary Delete Study Group Discipline Id
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudyGroupTasksApi
     */
    public deleteStudyGroupDisciplineId(id: number, options?: AxiosRequestConfig) {
        return StudyGroupTasksApiFp(this.configuration).deleteStudyGroupDisciplineId(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve StudyGroupTasks.
     * @summary Read Study Group Discipline
     * @param {string} [sort] Format: &#x60;[\&quot;field_name\&quot;, \&quot;direction\&quot;]&#x60;
     * @param {string} [range] Format: &#x60;[start, end]&#x60;
     * @param {string} [filter] Format: &#x60;{\&quot;id\&quot;: 0}&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudyGroupTasksApi
     */
    public readStudyGroupDiscipline(sort?: string, range?: string, filter?: string, options?: AxiosRequestConfig) {
        return StudyGroupTasksApiFp(this.configuration).readStudyGroupDiscipline(sort, range, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get StudyGroupTask by ID.
     * @summary Read Study Group Discipline Id
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudyGroupTasksApi
     */
    public readStudyGroupDisciplineId(id: number, options?: AxiosRequestConfig) {
        return StudyGroupTasksApiFp(this.configuration).readStudyGroupDisciplineId(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an StudyGroupTask.
     * @summary Update Study Group Discipline Id
     * @param {number} id 
     * @param {StudyGroupTaskUpdate} studyGroupTaskUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudyGroupTasksApi
     */
    public updateStudyGroupDisciplineId(id: number, studyGroupTaskUpdate: StudyGroupTaskUpdate, options?: AxiosRequestConfig) {
        return StudyGroupTasksApiFp(this.configuration).updateStudyGroupDisciplineId(id, studyGroupTaskUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StudyGroupsApi - axios parameter creator
 * @export
 */
export const StudyGroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new StudyGroup.
         * @summary Create Study Group
         * @param {StudyGroupCreate} studyGroupCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStudyGroup: async (studyGroupCreate: StudyGroupCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'studyGroupCreate' is not null or undefined
            assertParamExists('createStudyGroup', 'studyGroupCreate', studyGroupCreate)
            const localVarPath = `/api/v1/study_groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(studyGroupCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an StudyGroup.
         * @summary Delete Study Group Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStudyGroupId: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteStudyGroupId', 'id', id)
            const localVarPath = `/api/v1/study_groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve StudyGroups.
         * @summary Read Study Group
         * @param {string} [sort] Format: &#x60;[\&quot;field_name\&quot;, \&quot;direction\&quot;]&#x60;
         * @param {string} [range] Format: &#x60;[start, end]&#x60;
         * @param {string} [filter] Format: &#x60;{\&quot;id\&quot;: 0}&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readStudyGroup: async (sort?: string, range?: string, filter?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/study_groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (range !== undefined) {
                localVarQueryParameter['range'] = range;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get StudyGroup by ID.
         * @summary Read Study Group Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readStudyGroupId: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readStudyGroupId', 'id', id)
            const localVarPath = `/api/v1/study_groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an StudyGroup.
         * @summary Update Study Group Id
         * @param {string} id 
         * @param {StudyGroupUpdate} studyGroupUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStudyGroupId: async (id: string, studyGroupUpdate: StudyGroupUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateStudyGroupId', 'id', id)
            // verify required parameter 'studyGroupUpdate' is not null or undefined
            assertParamExists('updateStudyGroupId', 'studyGroupUpdate', studyGroupUpdate)
            const localVarPath = `/api/v1/study_groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(studyGroupUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StudyGroupsApi - functional programming interface
 * @export
 */
export const StudyGroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StudyGroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new StudyGroup.
         * @summary Create Study Group
         * @param {StudyGroupCreate} studyGroupCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createStudyGroup(studyGroupCreate: StudyGroupCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StudyGroup>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createStudyGroup(studyGroupCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an StudyGroup.
         * @summary Delete Study Group Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteStudyGroupId(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudyGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteStudyGroupId(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve StudyGroups.
         * @summary Read Study Group
         * @param {string} [sort] Format: &#x60;[\&quot;field_name\&quot;, \&quot;direction\&quot;]&#x60;
         * @param {string} [range] Format: &#x60;[start, end]&#x60;
         * @param {string} [filter] Format: &#x60;{\&quot;id\&quot;: 0}&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readStudyGroup(sort?: string, range?: string, filter?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StudyGroup>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readStudyGroup(sort, range, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get StudyGroup by ID.
         * @summary Read Study Group Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readStudyGroupId(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudyGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readStudyGroupId(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an StudyGroup.
         * @summary Update Study Group Id
         * @param {string} id 
         * @param {StudyGroupUpdate} studyGroupUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateStudyGroupId(id: string, studyGroupUpdate: StudyGroupUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudyGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateStudyGroupId(id, studyGroupUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StudyGroupsApi - factory interface
 * @export
 */
export const StudyGroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StudyGroupsApiFp(configuration)
    return {
        /**
         * Create new StudyGroup.
         * @summary Create Study Group
         * @param {StudyGroupCreate} studyGroupCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStudyGroup(studyGroupCreate: StudyGroupCreate, options?: any): AxiosPromise<Array<StudyGroup>> {
            return localVarFp.createStudyGroup(studyGroupCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an StudyGroup.
         * @summary Delete Study Group Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStudyGroupId(id: string, options?: any): AxiosPromise<StudyGroup> {
            return localVarFp.deleteStudyGroupId(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve StudyGroups.
         * @summary Read Study Group
         * @param {string} [sort] Format: &#x60;[\&quot;field_name\&quot;, \&quot;direction\&quot;]&#x60;
         * @param {string} [range] Format: &#x60;[start, end]&#x60;
         * @param {string} [filter] Format: &#x60;{\&quot;id\&quot;: 0}&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readStudyGroup(sort?: string, range?: string, filter?: string, options?: any): AxiosPromise<Array<StudyGroup>> {
            return localVarFp.readStudyGroup(sort, range, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Get StudyGroup by ID.
         * @summary Read Study Group Id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readStudyGroupId(id: string, options?: any): AxiosPromise<StudyGroup> {
            return localVarFp.readStudyGroupId(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an StudyGroup.
         * @summary Update Study Group Id
         * @param {string} id 
         * @param {StudyGroupUpdate} studyGroupUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStudyGroupId(id: string, studyGroupUpdate: StudyGroupUpdate, options?: any): AxiosPromise<StudyGroup> {
            return localVarFp.updateStudyGroupId(id, studyGroupUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StudyGroupsApi - object-oriented interface
 * @export
 * @class StudyGroupsApi
 * @extends {BaseAPI}
 */
export class StudyGroupsApi extends BaseAPI {
    /**
     * Create new StudyGroup.
     * @summary Create Study Group
     * @param {StudyGroupCreate} studyGroupCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudyGroupsApi
     */
    public createStudyGroup(studyGroupCreate: StudyGroupCreate, options?: AxiosRequestConfig) {
        return StudyGroupsApiFp(this.configuration).createStudyGroup(studyGroupCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an StudyGroup.
     * @summary Delete Study Group Id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudyGroupsApi
     */
    public deleteStudyGroupId(id: string, options?: AxiosRequestConfig) {
        return StudyGroupsApiFp(this.configuration).deleteStudyGroupId(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve StudyGroups.
     * @summary Read Study Group
     * @param {string} [sort] Format: &#x60;[\&quot;field_name\&quot;, \&quot;direction\&quot;]&#x60;
     * @param {string} [range] Format: &#x60;[start, end]&#x60;
     * @param {string} [filter] Format: &#x60;{\&quot;id\&quot;: 0}&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudyGroupsApi
     */
    public readStudyGroup(sort?: string, range?: string, filter?: string, options?: AxiosRequestConfig) {
        return StudyGroupsApiFp(this.configuration).readStudyGroup(sort, range, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get StudyGroup by ID.
     * @summary Read Study Group Id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudyGroupsApi
     */
    public readStudyGroupId(id: string, options?: AxiosRequestConfig) {
        return StudyGroupsApiFp(this.configuration).readStudyGroupId(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an StudyGroup.
     * @summary Update Study Group Id
     * @param {string} id 
     * @param {StudyGroupUpdate} studyGroupUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudyGroupsApi
     */
    public updateStudyGroupId(id: string, studyGroupUpdate: StudyGroupUpdate, options?: AxiosRequestConfig) {
        return StudyGroupsApiFp(this.configuration).updateStudyGroupId(id, studyGroupUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TasksApi - axios parameter creator
 * @export
 */
export const TasksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new task.
         * @summary Create Task
         * @param {TaskCreate} taskCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTask: async (taskCreate: TaskCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskCreate' is not null or undefined
            assertParamExists('createTask', 'taskCreate', taskCreate)
            const localVarPath = `/api/v1/tasks/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(taskCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an task.
         * @summary Delete Task
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTask: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTask', 'id', id)
            const localVarPath = `/api/v1/tasks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get task by ID.
         * @summary Read Task
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readTask: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readTask', 'id', id)
            const localVarPath = `/api/v1/tasks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve Tasks.
         * @summary Read Tasks
         * @param {string} [sort] Format: &#x60;[\&quot;field_name\&quot;, \&quot;direction\&quot;]&#x60;
         * @param {string} [range] Format: &#x60;[start, end]&#x60;
         * @param {string} [filter] Format: &#x60;{\&quot;id\&quot;: 0}&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readTasks: async (sort?: string, range?: string, filter?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/tasks/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (range !== undefined) {
                localVarQueryParameter['range'] = range;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an task.
         * @summary Update Task
         * @param {number} id 
         * @param {TaskUpdate} taskUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTask: async (id: number, taskUpdate: TaskUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTask', 'id', id)
            // verify required parameter 'taskUpdate' is not null or undefined
            assertParamExists('updateTask', 'taskUpdate', taskUpdate)
            const localVarPath = `/api/v1/tasks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(taskUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TasksApi - functional programming interface
 * @export
 */
export const TasksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TasksApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new task.
         * @summary Create Task
         * @param {TaskCreate} taskCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTask(taskCreate: TaskCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTask(taskCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an task.
         * @summary Delete Task
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTask(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTask(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get task by ID.
         * @summary Read Task
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readTask(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readTask(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve Tasks.
         * @summary Read Tasks
         * @param {string} [sort] Format: &#x60;[\&quot;field_name\&quot;, \&quot;direction\&quot;]&#x60;
         * @param {string} [range] Format: &#x60;[start, end]&#x60;
         * @param {string} [filter] Format: &#x60;{\&quot;id\&quot;: 0}&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readTasks(sort?: string, range?: string, filter?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Task>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readTasks(sort, range, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an task.
         * @summary Update Task
         * @param {number} id 
         * @param {TaskUpdate} taskUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTask(id: number, taskUpdate: TaskUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTask(id, taskUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TasksApi - factory interface
 * @export
 */
export const TasksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TasksApiFp(configuration)
    return {
        /**
         * Create new task.
         * @summary Create Task
         * @param {TaskCreate} taskCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTask(taskCreate: TaskCreate, options?: any): AxiosPromise<Task> {
            return localVarFp.createTask(taskCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an task.
         * @summary Delete Task
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTask(id: number, options?: any): AxiosPromise<Task> {
            return localVarFp.deleteTask(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get task by ID.
         * @summary Read Task
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readTask(id: number, options?: any): AxiosPromise<Task> {
            return localVarFp.readTask(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve Tasks.
         * @summary Read Tasks
         * @param {string} [sort] Format: &#x60;[\&quot;field_name\&quot;, \&quot;direction\&quot;]&#x60;
         * @param {string} [range] Format: &#x60;[start, end]&#x60;
         * @param {string} [filter] Format: &#x60;{\&quot;id\&quot;: 0}&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readTasks(sort?: string, range?: string, filter?: string, options?: any): AxiosPromise<Array<Task>> {
            return localVarFp.readTasks(sort, range, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an task.
         * @summary Update Task
         * @param {number} id 
         * @param {TaskUpdate} taskUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTask(id: number, taskUpdate: TaskUpdate, options?: any): AxiosPromise<Task> {
            return localVarFp.updateTask(id, taskUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TasksApi - object-oriented interface
 * @export
 * @class TasksApi
 * @extends {BaseAPI}
 */
export class TasksApi extends BaseAPI {
    /**
     * Create new task.
     * @summary Create Task
     * @param {TaskCreate} taskCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public createTask(taskCreate: TaskCreate, options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).createTask(taskCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an task.
     * @summary Delete Task
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public deleteTask(id: number, options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).deleteTask(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get task by ID.
     * @summary Read Task
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public readTask(id: number, options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).readTask(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve Tasks.
     * @summary Read Tasks
     * @param {string} [sort] Format: &#x60;[\&quot;field_name\&quot;, \&quot;direction\&quot;]&#x60;
     * @param {string} [range] Format: &#x60;[start, end]&#x60;
     * @param {string} [filter] Format: &#x60;{\&quot;id\&quot;: 0}&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public readTasks(sort?: string, range?: string, filter?: string, options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).readTasks(sort, range, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an task.
     * @summary Update Task
     * @param {number} id 
     * @param {TaskUpdate} taskUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public updateTask(id: number, taskUpdate: TaskUpdate, options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).updateTask(id, taskUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TeachersApi - axios parameter creator
 * @export
 */
export const TeachersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new Teacher.
         * @summary Create Teacher
         * @param {UserCreate} userCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeacher: async (userCreate: UserCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreate' is not null or undefined
            assertParamExists('createTeacher', 'userCreate', userCreate)
            const localVarPath = `/api/v1/teachers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Teacher.
         * @summary Delete Teacher Id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeacherId: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTeacherId', 'id', id)
            const localVarPath = `/api/v1/teachers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Teacher by ID.
         * @summary Read Teacher Id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readTeacherId: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readTeacherId', 'id', id)
            const localVarPath = `/api/v1/teachers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current teacher.
         * @summary Read Teacher Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readTeacherMe: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/teachers/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve Tasks.
         * @summary Read Teachers
         * @param {string} [sort] Format: &#x60;[\&quot;field_name\&quot;, \&quot;direction\&quot;]&#x60;
         * @param {string} [range] Format: &#x60;[start, end]&#x60;
         * @param {string} [filter] Format: &#x60;{\&quot;id\&quot;: 0}&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readTeachers: async (sort?: string, range?: string, filter?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/teachers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (range !== undefined) {
                localVarQueryParameter['range'] = range;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Teacher.
         * @summary Update Teacher Id
         * @param {number} id 
         * @param {TeacherUpdate} teacherUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeacherId: async (id: number, teacherUpdate: TeacherUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTeacherId', 'id', id)
            // verify required parameter 'teacherUpdate' is not null or undefined
            assertParamExists('updateTeacherId', 'teacherUpdate', teacherUpdate)
            const localVarPath = `/api/v1/teachers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(teacherUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeachersApi - functional programming interface
 * @export
 */
export const TeachersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TeachersApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new Teacher.
         * @summary Create Teacher
         * @param {UserCreate} userCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTeacher(userCreate: UserCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Teacher>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTeacher(userCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a Teacher.
         * @summary Delete Teacher Id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTeacherId(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Teacher>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTeacherId(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Teacher by ID.
         * @summary Read Teacher Id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readTeacherId(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Teacher>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readTeacherId(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get current teacher.
         * @summary Read Teacher Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readTeacherMe(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Teacher>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readTeacherMe(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve Tasks.
         * @summary Read Teachers
         * @param {string} [sort] Format: &#x60;[\&quot;field_name\&quot;, \&quot;direction\&quot;]&#x60;
         * @param {string} [range] Format: &#x60;[start, end]&#x60;
         * @param {string} [filter] Format: &#x60;{\&quot;id\&quot;: 0}&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readTeachers(sort?: string, range?: string, filter?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Teacher>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readTeachers(sort, range, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a Teacher.
         * @summary Update Teacher Id
         * @param {number} id 
         * @param {TeacherUpdate} teacherUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTeacherId(id: number, teacherUpdate: TeacherUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Teacher>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTeacherId(id, teacherUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TeachersApi - factory interface
 * @export
 */
export const TeachersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TeachersApiFp(configuration)
    return {
        /**
         * Create new Teacher.
         * @summary Create Teacher
         * @param {UserCreate} userCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeacher(userCreate: UserCreate, options?: any): AxiosPromise<Teacher> {
            return localVarFp.createTeacher(userCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Teacher.
         * @summary Delete Teacher Id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeacherId(id: number, options?: any): AxiosPromise<Teacher> {
            return localVarFp.deleteTeacherId(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Teacher by ID.
         * @summary Read Teacher Id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readTeacherId(id: number, options?: any): AxiosPromise<Teacher> {
            return localVarFp.readTeacherId(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current teacher.
         * @summary Read Teacher Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readTeacherMe(options?: any): AxiosPromise<Array<Teacher>> {
            return localVarFp.readTeacherMe(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve Tasks.
         * @summary Read Teachers
         * @param {string} [sort] Format: &#x60;[\&quot;field_name\&quot;, \&quot;direction\&quot;]&#x60;
         * @param {string} [range] Format: &#x60;[start, end]&#x60;
         * @param {string} [filter] Format: &#x60;{\&quot;id\&quot;: 0}&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readTeachers(sort?: string, range?: string, filter?: string, options?: any): AxiosPromise<Array<Teacher>> {
            return localVarFp.readTeachers(sort, range, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Teacher.
         * @summary Update Teacher Id
         * @param {number} id 
         * @param {TeacherUpdate} teacherUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeacherId(id: number, teacherUpdate: TeacherUpdate, options?: any): AxiosPromise<Teacher> {
            return localVarFp.updateTeacherId(id, teacherUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TeachersApi - object-oriented interface
 * @export
 * @class TeachersApi
 * @extends {BaseAPI}
 */
export class TeachersApi extends BaseAPI {
    /**
     * Create new Teacher.
     * @summary Create Teacher
     * @param {UserCreate} userCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeachersApi
     */
    public createTeacher(userCreate: UserCreate, options?: AxiosRequestConfig) {
        return TeachersApiFp(this.configuration).createTeacher(userCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a Teacher.
     * @summary Delete Teacher Id
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeachersApi
     */
    public deleteTeacherId(id: number, options?: AxiosRequestConfig) {
        return TeachersApiFp(this.configuration).deleteTeacherId(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Teacher by ID.
     * @summary Read Teacher Id
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeachersApi
     */
    public readTeacherId(id: number, options?: AxiosRequestConfig) {
        return TeachersApiFp(this.configuration).readTeacherId(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current teacher.
     * @summary Read Teacher Me
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeachersApi
     */
    public readTeacherMe(options?: AxiosRequestConfig) {
        return TeachersApiFp(this.configuration).readTeacherMe(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve Tasks.
     * @summary Read Teachers
     * @param {string} [sort] Format: &#x60;[\&quot;field_name\&quot;, \&quot;direction\&quot;]&#x60;
     * @param {string} [range] Format: &#x60;[start, end]&#x60;
     * @param {string} [filter] Format: &#x60;{\&quot;id\&quot;: 0}&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeachersApi
     */
    public readTeachers(sort?: string, range?: string, filter?: string, options?: AxiosRequestConfig) {
        return TeachersApiFp(this.configuration).readTeachers(sort, range, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a Teacher.
     * @summary Update Teacher Id
     * @param {number} id 
     * @param {TeacherUpdate} teacherUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeachersApi
     */
    public updateTeacherId(id: number, teacherUpdate: TeacherUpdate, options?: AxiosRequestConfig) {
        return TeachersApiFp(this.configuration).updateTeacherId(id, teacherUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new user.
         * @summary Create User
         * @param {UserCreate} userCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (userCreate: UserCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreate' is not null or undefined
            assertParamExists('createUser', 'userCreate', userCreate)
            const localVarPath = `/api/v1/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate report by user id.
         * @summary Create User Report
         * @param {ReportUserCreate} reportUserCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserReport: async (reportUserCreate: ReportUserCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reportUserCreate' is not null or undefined
            assertParamExists('createUserReport', 'reportUserCreate', reportUserCreate)
            const localVarPath = `/api/v1/users/report`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reportUserCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an task.
         * @summary Delete User
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteUser', 'id', id)
            const localVarPath = `/api/v1/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific user by id.
         * @summary Read User By Id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readUserById: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readUserById', 'id', id)
            const localVarPath = `/api/v1/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current user.
         * @summary Read User Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readUserMe: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve users.
         * @summary Read Users
         * @param {string} [sort] Format: &#x60;[\&quot;field_name\&quot;, \&quot;direction\&quot;]&#x60;
         * @param {string} [range] Format: &#x60;[start, end]&#x60;
         * @param {string} [filter] Format: &#x60;{\&quot;id\&quot;: 0}&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readUsers: async (sort?: string, range?: string, filter?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (range !== undefined) {
                localVarQueryParameter['range'] = range;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve users.
         * @summary Read Users By Role Id
         * @param {string} rolname 
         * @param {string} [sort] Format: &#x60;[\&quot;field_name\&quot;, \&quot;direction\&quot;]&#x60;
         * @param {string} [range] Format: &#x60;[start, end]&#x60;
         * @param {string} [filter] Format: &#x60;{\&quot;id\&quot;: 0}&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readUsersByRoleId: async (rolname: string, sort?: string, range?: string, filter?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rolname' is not null or undefined
            assertParamExists('readUsersByRoleId', 'rolname', rolname)
            const localVarPath = `/api/v1/users/role/{rolname}`
                .replace(`{${"rolname"}}`, encodeURIComponent(String(rolname)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (range !== undefined) {
                localVarQueryParameter['range'] = range;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a user.
         * @summary Update User
         * @param {number} id 
         * @param {UserUpdate} userUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (id: number, userUpdate: UserUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUser', 'id', id)
            // verify required parameter 'userUpdate' is not null or undefined
            assertParamExists('updateUser', 'userUpdate', userUpdate)
            const localVarPath = `/api/v1/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a user by role.
         * @summary Update User By Role
         * @param {string} rolname 
         * @param {number} id 
         * @param {UserUpdate} userUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserByRole: async (rolname: string, id: number, userUpdate: UserUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rolname' is not null or undefined
            assertParamExists('updateUserByRole', 'rolname', rolname)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUserByRole', 'id', id)
            // verify required parameter 'userUpdate' is not null or undefined
            assertParamExists('updateUserByRole', 'userUpdate', userUpdate)
            const localVarPath = `/api/v1/users/role/{rolname}/{id}`
                .replace(`{${"rolname"}}`, encodeURIComponent(String(rolname)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update own user.
         * @summary Update User Me
         * @param {BodyUpdateUserMeApiV1UsersMePut} [bodyUpdateUserMeApiV1UsersMePut] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserMe: async (bodyUpdateUserMeApiV1UsersMePut?: BodyUpdateUserMeApiV1UsersMePut, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bodyUpdateUserMeApiV1UsersMePut, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new user.
         * @summary Create User
         * @param {UserCreate} userCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(userCreate: UserCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(userCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generate report by user id.
         * @summary Create User Report
         * @param {ReportUserCreate} reportUserCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserReport(reportUserCreate: ReportUserCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserReport(reportUserCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an task.
         * @summary Delete User
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a specific user by id.
         * @summary Read User By Id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readUserById(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readUserById(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get current user.
         * @summary Read User Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readUserMe(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readUserMe(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve users.
         * @summary Read Users
         * @param {string} [sort] Format: &#x60;[\&quot;field_name\&quot;, \&quot;direction\&quot;]&#x60;
         * @param {string} [range] Format: &#x60;[start, end]&#x60;
         * @param {string} [filter] Format: &#x60;{\&quot;id\&quot;: 0}&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readUsers(sort?: string, range?: string, filter?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readUsers(sort, range, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve users.
         * @summary Read Users By Role Id
         * @param {string} rolname 
         * @param {string} [sort] Format: &#x60;[\&quot;field_name\&quot;, \&quot;direction\&quot;]&#x60;
         * @param {string} [range] Format: &#x60;[start, end]&#x60;
         * @param {string} [filter] Format: &#x60;{\&quot;id\&quot;: 0}&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readUsersByRoleId(rolname: string, sort?: string, range?: string, filter?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readUsersByRoleId(rolname, sort, range, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a user.
         * @summary Update User
         * @param {number} id 
         * @param {UserUpdate} userUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(id: number, userUpdate: UserUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(id, userUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a user by role.
         * @summary Update User By Role
         * @param {string} rolname 
         * @param {number} id 
         * @param {UserUpdate} userUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserByRole(rolname: string, id: number, userUpdate: UserUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserByRole(rolname, id, userUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update own user.
         * @summary Update User Me
         * @param {BodyUpdateUserMeApiV1UsersMePut} [bodyUpdateUserMeApiV1UsersMePut] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserMe(bodyUpdateUserMeApiV1UsersMePut?: BodyUpdateUserMeApiV1UsersMePut, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserMe(bodyUpdateUserMeApiV1UsersMePut, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Create new user.
         * @summary Create User
         * @param {UserCreate} userCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(userCreate: UserCreate, options?: any): AxiosPromise<User> {
            return localVarFp.createUser(userCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate report by user id.
         * @summary Create User Report
         * @param {ReportUserCreate} reportUserCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserReport(reportUserCreate: ReportUserCreate, options?: any): AxiosPromise<void> {
            return localVarFp.createUserReport(reportUserCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an task.
         * @summary Delete User
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(id: number, options?: any): AxiosPromise<User> {
            return localVarFp.deleteUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific user by id.
         * @summary Read User By Id
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readUserById(id: number, options?: any): AxiosPromise<User> {
            return localVarFp.readUserById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current user.
         * @summary Read User Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readUserMe(options?: any): AxiosPromise<Array<User>> {
            return localVarFp.readUserMe(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve users.
         * @summary Read Users
         * @param {string} [sort] Format: &#x60;[\&quot;field_name\&quot;, \&quot;direction\&quot;]&#x60;
         * @param {string} [range] Format: &#x60;[start, end]&#x60;
         * @param {string} [filter] Format: &#x60;{\&quot;id\&quot;: 0}&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readUsers(sort?: string, range?: string, filter?: string, options?: any): AxiosPromise<Array<User>> {
            return localVarFp.readUsers(sort, range, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve users.
         * @summary Read Users By Role Id
         * @param {string} rolname 
         * @param {string} [sort] Format: &#x60;[\&quot;field_name\&quot;, \&quot;direction\&quot;]&#x60;
         * @param {string} [range] Format: &#x60;[start, end]&#x60;
         * @param {string} [filter] Format: &#x60;{\&quot;id\&quot;: 0}&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readUsersByRoleId(rolname: string, sort?: string, range?: string, filter?: string, options?: any): AxiosPromise<Array<User>> {
            return localVarFp.readUsersByRoleId(rolname, sort, range, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a user.
         * @summary Update User
         * @param {number} id 
         * @param {UserUpdate} userUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(id: number, userUpdate: UserUpdate, options?: any): AxiosPromise<User> {
            return localVarFp.updateUser(id, userUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a user by role.
         * @summary Update User By Role
         * @param {string} rolname 
         * @param {number} id 
         * @param {UserUpdate} userUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserByRole(rolname: string, id: number, userUpdate: UserUpdate, options?: any): AxiosPromise<User> {
            return localVarFp.updateUserByRole(rolname, id, userUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Update own user.
         * @summary Update User Me
         * @param {BodyUpdateUserMeApiV1UsersMePut} [bodyUpdateUserMeApiV1UsersMePut] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserMe(bodyUpdateUserMeApiV1UsersMePut?: BodyUpdateUserMeApiV1UsersMePut, options?: any): AxiosPromise<User> {
            return localVarFp.updateUserMe(bodyUpdateUserMeApiV1UsersMePut, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Create new user.
     * @summary Create User
     * @param {UserCreate} userCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createUser(userCreate: UserCreate, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).createUser(userCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate report by user id.
     * @summary Create User Report
     * @param {ReportUserCreate} reportUserCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createUserReport(reportUserCreate: ReportUserCreate, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).createUserReport(reportUserCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an task.
     * @summary Delete User
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUser(id: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a specific user by id.
     * @summary Read User By Id
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public readUserById(id: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).readUserById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current user.
     * @summary Read User Me
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public readUserMe(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).readUserMe(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve users.
     * @summary Read Users
     * @param {string} [sort] Format: &#x60;[\&quot;field_name\&quot;, \&quot;direction\&quot;]&#x60;
     * @param {string} [range] Format: &#x60;[start, end]&#x60;
     * @param {string} [filter] Format: &#x60;{\&quot;id\&quot;: 0}&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public readUsers(sort?: string, range?: string, filter?: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).readUsers(sort, range, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve users.
     * @summary Read Users By Role Id
     * @param {string} rolname 
     * @param {string} [sort] Format: &#x60;[\&quot;field_name\&quot;, \&quot;direction\&quot;]&#x60;
     * @param {string} [range] Format: &#x60;[start, end]&#x60;
     * @param {string} [filter] Format: &#x60;{\&quot;id\&quot;: 0}&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public readUsersByRoleId(rolname: string, sort?: string, range?: string, filter?: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).readUsersByRoleId(rolname, sort, range, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a user.
     * @summary Update User
     * @param {number} id 
     * @param {UserUpdate} userUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUser(id: number, userUpdate: UserUpdate, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUser(id, userUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a user by role.
     * @summary Update User By Role
     * @param {string} rolname 
     * @param {number} id 
     * @param {UserUpdate} userUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserByRole(rolname: string, id: number, userUpdate: UserUpdate, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUserByRole(rolname, id, userUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update own user.
     * @summary Update User Me
     * @param {BodyUpdateUserMeApiV1UsersMePut} [bodyUpdateUserMeApiV1UsersMePut] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserMe(bodyUpdateUserMeApiV1UsersMePut?: BodyUpdateUserMeApiV1UsersMePut, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUserMe(bodyUpdateUserMeApiV1UsersMePut, options).then((request) => request(this.axios, this.basePath));
    }
}


